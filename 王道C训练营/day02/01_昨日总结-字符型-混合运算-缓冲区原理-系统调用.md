# 昨日思维导图

![](C:\Users\23614\Desktop\C语言\image\day01.png)



# 字符型

首先，在C语言中，字符型赋值只能用''括起来，不能用“” 

``` C
int main(){		
	char a = "A";		//错误的，但C语言只会警告，不会阻止编译，过于灵活了，cpp就会阻止
	printf("%c\n", a);
	printf("%d\n", a);
	system("pause");
}
```

可以对char型进行加减运算，是按ascii码的

## 内存中：

![image-20221105165230418](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105165230418.png)

字符在内存里存储的方式也是0101

不要有，我是往里面填了一个字符进去，我们才能够输出一个字符，

内存里都是16进制数值（从内存视图上看），都是0101bit流，从中取出，

输出是字符的原因是printf控制字符是%c，于是把内存里的0101等，再按照ascii码之类的编码方式译成字符



趣闻：连续俩个0XCC会输出烫；

## ascii码

![image-20221105170429631](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105170429631.png)

ascii码英文或其他字符一个字节，中文汉字俩个字节

大写字母转小写字母+32，反之亦然。

32代表空格，而0代表四大皆空

在任何一个字符串的最后，都有一个结束符，这样我们才知道这个字符串结束了。

这个结束符号\0最终存进去的数据就是0000 0000，一字节

![](C:\Users\23614\Desktop\C语言\image\内存图abc.png)



## 转义字符

![image-20221105170550784](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105170550784.png)

特别备注：转义字符是分大小写的，用\R之类的是无效的。会直接输出R

\r标注回车，是让光标回到行首。

例如输出"abcd/rz",z会把a给覆盖掉，而不是往后推，往后推是文本编辑器干的活，重新打印的



![](C:\Users\23614\Desktop\C语言\image\烫.png)



\b就是光标往前移一格，配合用空格覆盖的思想，可以实现删除/修改某字符的显示功能。

空格覆盖后，要记得再\b一次回来，不然空格就暴露了。

![](C:\Users\23614\Desktop\C语言\image\回退字符.png)



\t:用来控制格式对齐，有些是输出四个空格，有些八个



## 字符串常量

```c
char *a = ""//空字符串，也是字符串，其实里面还有\0结束符
char *a = "a"//“”里一个字符也是字符串，不是字符，后面又\0
```





# 混合运算

![image-20221105183248149](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105183248149.png)

相同类型，例如整形：int short long混合运算，系统自动将短字节转成长字节

短字节转长字节会报warning，编译时一般只通过类型来检查，而不是立即数。

## 经典例子

![image-20221105183925661](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105183925661.png)

这个例子就想说明，整形在运算时是以int型（4字节）为存储空间进行运算的

![image-20221106230627031](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221106230627031.png)

第一个等号右边进行的都是0x93这十六进制整数的左右移动，以四字节位为空间，移位不会导致符号位/截短



进行c=0x93《1时：

0000 0000 0000 0000 0000 0000    1001 0011

左移1位：

0000 0000 0000 0000 0000 0001	 0010 0110

***然后赋值给c（c是char型的啊，只能接收1字节数据，故前面的会被截）***

c此时等于：0010 0110

然后再c = c》1右移一位

c此时等于：0001 0011

用%x输出，不就是13么，理所当然。



# 相乘溢出

## 整型相乘

![image-20221105184042109](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105184042109.png)

![image-20221105184707838](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105184707838.png)

![image-20221105184835337](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105184835337.png)

以上三个都不会输出正确答案。

究其原因，整数做加减乘除，系统会把他们默认当成int型数据加减乘除，最终得到一个int型数据，再赋给变量。

此时变量就算可接收再长的数据，也已经无济于事了，截断早就在运算加法器阶段就开始了。

所以，很多时候整形运算，一定要记得强转。

正确输出：

![image-20221105184956449](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105184956449.png)

64位环境下只需要%ld，long就行；32位long也只是4字节



## 浮点型相乘

浮点数在运算阶段就把自己当成8字节，

把他赋值给float型变量，自然会发生截断产生错误。

而如果正常直接输出，或者做运算再输出，默认将以8字节为存储空间。

![image-20221105194213974](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105194213974.png)







# 读取标准/系统调用/缓冲

## 系统标准

以printf()为例，解析系统调用过程

系统调用也叫程序接口，是应用程序请求OS内核完成某功能时的一种过程调用，是用户程序对OS内核功能进行调用的一种手段。

①用户在应用程序中调用printf()函数，此时执行访管指令INT Ox80产生编程异常，系统进行中断处理，处理器从用户态切换到系统态并保存中断时CPU现场信息，***并使堆栈切换到内核栈。***

②查找中断描述符号表，得到异常的中断处理程序的入口地址。

③执行system-call()函数，继续保护中断现场信息并检查本次系统调用的正确性。若通过检查，则利用EAX寄存器传递过来的系统调用号查找系统调用入口表，找到这个系统调用的服务例程的入口地址。

④执行write()服务例程。

⑤恢复被中断进程的CPU现场信息，返回被中断进程，继续运行。

``` c
	//scanf，printf都是系统调用
	//所有读取标准输入的这个接口，都是通过系统调用来实现的
	//只有系统调用，才能够访问系统内核，进行中断操作
	//任何在缓冲区里的东西，全部都是字符，scanf可以干把整形之类的数据换成字符型
```

![image-20221105201951531](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105201951531.png)

![image-20221105220227243](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105220227243.png)

stderr标准错误缓冲区

## scanf

scanf函数会阻塞

所有读取标准输入缓冲区的函数都有这个机制，都通过系统调用这个接口实现

这个接口的特点就是，会阻塞，当你缓冲区里是空的时候，scanf到这里就会卡住，阻塞

当处于阻塞状态的时候，我们的程序处于 休眠状态，有内存，但cpu占用率为0

![image-20221105202148791](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105202148791.png)



## 缓冲区原理

![image-20221105202512848](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105202512848.png)

全缓冲，磁盘和cpu速度差的很多往里写很慢暂且不说，且老是往里写东西很容易坏，全缓冲就是等这个缓冲区满了（例4k）就把这一块给完整写入磁盘。





## 关于scanf("%c",&i)

![image-20221105202715009](C:\Users\23614\AppData\Roaming\Typora\typora-user-images\image-20221105202715009.png)

一个很老，但却是挺经典的例子，但我已经不再是那个萌新了

%c会接收空格，回车

只有匹配上了才会删除缓冲区的相应内容。

%d只会匹配0~9，

%f比起多匹配一个.

而%c任何字符都能匹配







